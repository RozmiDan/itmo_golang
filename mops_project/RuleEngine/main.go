// rule-engine/main.go
package main

import (
	"context"
	"encoding/json"
	"flag"
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/streadway/amqp"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type DataMessage struct {
	DeviceID  int     `json:"device_id"`
	FieldA    float64 `json:"field_a"`
	FieldB    float64 `json:"field_b"`
	RuleField int     `json:"rule_fld"`
}

type Alert struct {
	DeviceID    int       `json:"device_id"`
	Rule        string    `json:"rule"`
	Timestamp   time.Time `json:"timestamp"`
}

var alertCollection *mongo.Collection
var deviceHistory map[int][]int // Для хранения истории значений FieldA по каждому устройству

// ---------- PROMETHEUS МЕТРИКИ ----------

// Счётчик количества полученных сообщений (разбивка по device_id)
var messagesReceived = prometheus.NewCounterVec(
	prometheus.CounterOpts{
		Name: "rule_engine_messages_received_total",
		Help: "Number of messages received by device ID",
	},
	[]string{"device_id"},
)

// Счётчик количества сгенерированных алертов
var alertsGenerated = prometheus.NewCounter(
	prometheus.CounterOpts{
		Name: "rule_engine_alerts_generated_total",
		Help: "Number of alerts generated by rule engine",
	},
)


func main() {
	var amqpURL, queueName string
	var mongoURI string
	var mongoDBName, mongoCollName string

	// Парсим флаги
	flag.StringVar(&amqpURL, "amqp", "amqp://guest:guest@localhost:5672/", "AMQP URL")
	flag.StringVar(&queueName, "queue", "iot_data", "RabbitMQ queue name")

	flag.StringVar(&mongoURI, "mongo-uri", "mongodb://localhost:27017", "MongoDB URI")
	flag.StringVar(&mongoDBName, "mongo-db", "iot_db", "MongoDB database name")
	flag.StringVar(&mongoCollName, "mongo-coll", "alerts", "MongoDB collection name")
	flag.Parse()

	// 1. Подключаемся к MongoDB
	client, err := mongo.Connect(context.Background(), options.Client().ApplyURI(mongoURI))
	if err != nil {
		log.Fatalf("Failed to connect to MongoDB: %v", err)
	}
	defer func() {
		if err = client.Disconnect(context.Background()); err != nil {
			log.Printf("Error disconnecting MongoDB: %v", err)
		}
	}()
	alertCollection = client.Database(mongoDBName).Collection(mongoCollName)

	// 2. Подключаемся к RabbitMQ
	conn, err := amqp.Dial(amqpURL)
	if err != nil {
		log.Fatalf("Failed to connect to RabbitMQ: %v", err)
	}
	defer conn.Close()

	ch, err := conn.Channel()
	if err != nil {
		log.Fatalf("Failed to open a channel: %v", err)
	}
	defer ch.Close()

	// Убеждаемся, что очередь объявлена
	_, err = ch.QueueDeclare(queueName, false, false, false, false, nil)
	if err != nil {
		log.Fatalf("Failed to declare a queue: %v", err)
	}

	// Подписываемся на очередь
	msgs, err := ch.Consume(queueName, "", true, false, false, false, nil)
	if err != nil {
		log.Fatalf("Failed to register a consumer: %v", err)
	}

	log.Printf("Rule Engine is listening on queue %q, writing alerts to MongoDB: %s/%s", queueName, mongoDBName, mongoCollName)

	deviceHistory = make(map[int][]int) // Инициализируем историю

	// ---------- PROMETHEUS СЕРВЕР /metrics ----------
	// Регистрируем наши кастомные метрики в Prometheus
	prometheus.MustRegister(messagesReceived)
	prometheus.MustRegister(alertsGenerated)

	// Запускаем в отдельной горутине небольшой HTTP-сервер для отдачи метрик
	go func() {
		http.Handle("/metrics", promhttp.Handler())
		log.Println("Prometheus metrics endpoint is running on :2112/metrics")
		log.Fatal(http.ListenAndServe(":2112", nil))
	}()

	// 3. Слушаем сообщения и проверяем правила
	go func() {
		for d := range msgs {
			var msg DataMessage
			if err := json.Unmarshal(d.Body, &msg); err != nil {
				log.Printf("Error unmarshaling message: %v", err)
				continue
			}
			log.Printf("Received message: %+v", msg)

			// Увеличиваем счётчик полученных сообщений для deviceID
			messagesReceived.With(prometheus.Labels{"device_id": strconv.Itoa(msg.DeviceID)}).Inc()

			// Правило 1: если RuleField > 99
			if msg.RuleField > 99 {
				alert := Alert{
					DeviceID:  msg.DeviceID,
					Rule:      "RuleField > 99",
					Timestamp: time.Now(),
				}
				saveAlert(alert)
			}

			// Правило 2: если три подряд пакета с RuleField > 50 для одного устройства
			if len(deviceHistory[msg.DeviceID]) >= 3 {
				if deviceHistory[msg.DeviceID][0] > 50 &&
					deviceHistory[msg.DeviceID][1] > 50 &&
					deviceHistory[msg.DeviceID][2] > 50 {
					alert := Alert{
						DeviceID:  msg.DeviceID,
						Rule:      "RuleField > 50 for 3 consecutive packets",
						Timestamp: time.Now(),
					}
					saveAlert(alert)
				}
			}

			// Добавляем текущее значение в историю устройства
			deviceHistory[msg.DeviceID] = append(deviceHistory[msg.DeviceID], msg.RuleField)
			if len(deviceHistory[msg.DeviceID]) > 3 {
				// Храним только последние 3 пакета
				deviceHistory[msg.DeviceID] = deviceHistory[msg.DeviceID][1:]
			}
		}
	}()

	// Чтобы программа не завершалась
	select {}
}

// Функция для записи алерта в MongoDB
func saveAlert(alert Alert) {
	_, err := alertCollection.InsertOne(context.Background(), alert)
	if err != nil {
		log.Printf("Failed to insert alert: %v", err)
	} else {
		log.Printf("Alert created: %+v", alert)
		// Увеличиваем счётчик сгенерированных алертов
		alertsGenerated.Inc()
	}
}
